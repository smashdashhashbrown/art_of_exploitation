#include <libnet.h>
#include <pcap.h>
#include "../include/hacking.h"

#define MAX_EXISTING_PORTS 30

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *, u_short *);

int main(int argc, char *argv[])
{
    pcap_t             *pcap_handle;
    char               errbuf[PCAP_ERRBUF_SIZE];
    char               *device;
    u_long             target_ip;
    libnet_t           *libnet_cxt;
    pcap_if_t          *all_devices;
    u_short            ports[MAX_EXISTING_PORTS + 1];

    if ((argc < 2) || (argc > (MAX_EXISTING_PORTS + 2))) {
        if (argc > (MAX_EXISTING_PORTS + 2))
            printf("Warning: limited to %d existing ports.\n", MAX_EXISTING_PORTS);
        else
            printf("Usage: %s <IP to shroud> [existing ports...]\n", argv[0]);
        return EXIT_FAILURE;
    }

    libnet_cxt = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (libnet_cxt == NULL) {
        hacking_fatal("libnet_init", errbuf);
    }

    target_ip = libnet_name2addr4(libnet_cxt, argv[1], LIBNET_RESOLVE);
    if (target_ip == -1) {
        hacking_fatal("libnet_name2addr4", libnet_geterror(libnet_cxt));
    }

    for (int i = 2; i < argc; i++) {
        ports[i-2] = (u_short) atoi(argv[i]);
    }
    ports[argc-2] = 0;

    pcap_findalldevs(&all_devices, errbuf);
    if (all_devices == NULL) {
        hacking_fatal("pcap_findalldevs", errbuf);
    }
    device = all_devices->next->name;
    printf("+ Utilizing device: %s\n", device);

    pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);
    if (pcap_handle == NULL) {
        hacking_fatal("pcap_open_live", errbuf);
    }

    if (libnet_open_raw4(libnet_cxt) == -1) {
        hacking_fatal("libnet_open_raw4", libnet_geterror(libnet_cxt));
    }

    libnet_seed_prand(libnet_cxt);

    set_packet_filter(pcap_handle, (struct in_addr *)&target_ip, ports);

    pcap_loop(pcap_handle, -1, caught_packet, (u_char *)libnet_cxt);
    pcap_close(pcap_handle);

    return EXIT_SUCCESS;
}

int set_packet_filter(pcap_t *pcap_handle, struct in_addr *target_ip, u_short *ports) {
    struct bpf_program filter;
    char *ptr;
    char filter_str[90 + (25 * MAX_EXISTING_PORTS)] = {0};
    int port_count = 0;

    sprintf(filter_str, "dst host %s and ", inet_ntoa(*target_ip));
    strcat(filter_str, "tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0");

    if (ports[0] != 0) {
        ptr = filter_str + strlen(filter_str);
        if (ports[1] == 0) {
            sprintf(ptr, " and not dst port %hu", ports[port_count]);
        } else {
            sprintf(ptr, " and not (dst port %hu", ports[port_count++]);
            while (ports[port_count] != 0) {
                ptr = filter_str + strlen(filter_str);
                sprintf(ptr, " or dst port %hu", ports[port_count++]);
            }
            strcat(filter_str, ")");
        }
    }

    // Cheap fix to un-used variable warning for 'ptr'
    // TODO: find better solution
    ptr = filter_str;
    printf("\tDebug: Filter String is below\n\t'%s'\n", ptr);
    if (pcap_compile(pcap_handle, &filter, filter_str, 0, 0) == -1) {
        hacking_fatal("pcap_compile", "failed to compile.\n");
    }

    if (pcap_setfilter(pcap_handle, &filter) == -1) {
        hacking_fatal("pcap_setfilter", "failed to set filter.\n");
    }

    return EXIT_SUCCESS;
}

void caught_packet(u_char *user_args,
                   const struct pcap_pkthdr *header,
                   const u_char *pkt)
{
    struct libnet_ipv4_hdr *ip_hdr;
    struct libnet_tcp_hdr *tcp_hdr;
    libnet_t *cxt;
    int bcount;

    cxt = (libnet_t *) user_args;

    ip_hdr = (struct libnet_ipv4_hdr *) (pkt + LIBNET_ETH_H);
    tcp_hdr = (struct libnet_tcp_hdr *) (pkt + LIBNET_ETH_H + LIBNET_IPV4_H);

    libnet_build_tcp(htons(tcp_hdr->th_dport), 
                     htons(tcp_hdr->th_sport),
                     htonl(tcp_hdr->th_ack),
                     htonl((tcp_hdr->th_seq) + 1),
                     TH_SYN | TH_ACK, // Shrouding, so down port will still send SYN/ACK
                     libnet_get_prand(LIBNET_PRu16),
                     0,
                     0,
                     LIBNET_TCP_H,
                     NULL,
                     0,
                     cxt,
                     0);

    libnet_build_ipv4(LIBNET_IPV4_H,
                      IPTOS_LOWDELAY,
                      libnet_get_prand(LIBNET_PRu16),
                      0,
                      libnet_get_prand(LIBNET_PR8),
                      IPPROTO_TCP,
                      0,
                      *((u_long *)&(ip_hdr->ip_dst)),
                      *((u_long *)&(ip_hdr->ip_src)),
                      NULL,
                      0,
                      cxt,
                      0);

    bcount = libnet_write(cxt);
    if (bcount != LIBNET_IPV4_H + LIBNET_TCP_H) {
        hacking_fatal("libnet_write", libnet_geterror(cxt));
    }
    libnet_clear_packet(cxt);
}